import { Injectable, UnauthorizedException, ConflictException, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../shared/database';
import { LoginDto, LoginResponseDto, InitiateDto, InitiateResponseDto, RegisterDto, RegisterResponseDto } from './dto/auth.dto';
import { SendOtpResponseDto, VerifyOtpResponseDto } from '../sms/dto/otp.dto';
import { UserService } from '../users/user.service';
import { SmsService, OtpService } from '../sms';
import { JwtService } from '../../shared/auth';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private userService: UserService,
    private smsService: SmsService,
    private otpService: OtpService,
    private jwtService: JwtService,
  ) {}

  async initiate(initiateDto: InitiateDto): Promise<InitiateResponseDto> {
    // Input validation and sanitization
    const phone = initiateDto.phone.trim();
    
    // Validate phone format (Iranian format: 9xxxxxxxxx)
    if (!/^9[0-9]{9}$/.test(phone)) {
      throw new Error('Invalid phone number format');
    }

    // Check if user exists
    const user = await this.prisma.user.findUnique({
      where: { phone },
      select: { id: true },
    });

    if (!user) {
      return {
        userExists: false,
        message: 'User not found, please proceed to registration',
        nextAction: 'register',
      };
    }

    // User exists, proceed to login
    return {
      userExists: true,
      message: 'User exists, please proceed to login',
      nextAction: 'login',
    };
  }

  async login(loginDto: LoginDto): Promise<LoginResponseDto> {
    const user = await this.prisma.user.findUnique({
      where: { phone: loginDto.phone },
    });
    
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Compare hashed password
    const isPasswordValid = await bcrypt.compare(loginDto.password, user.password);
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Generate real JWT token
    const tokenResult = this.jwtService.generateToken(user.id, user.phone, user.roles);
    const accessToken = tokenResult.accessToken;

    return {
      accessToken,
      user: {
        id: user.id,
        uuid: user.uuid,
        phone: user.phone,
        roles: (user as any).roles || ['user'], // Temporary fix until Prisma generates
        isPhoneVerified: user.isPhoneVerified,
        isEmailVerified: user.isEmailVerified,
        isVerified: user.isVerified,
      },
    };
  }

  async register(registerDto: RegisterDto): Promise<RegisterResponseDto> {
    // Input validation and sanitization
    const phone = registerDto.phone.trim();
    
    // Validate phone format (Iranian format: 9xxxxxxxxx)
    if (!/^9[0-9]{9}$/.test(phone)) {
      throw new Error('Invalid phone number format');
    }

    // Check if user already exists
    const existingUser = await this.prisma.user.findUnique({
      where: { phone },
      select: { id: true },
    });

    if (existingUser) {
      throw new ConflictException('User with this phone number already exists');
    }

    // Hash password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(registerDto.password, saltRounds);

    // Create new user with default values
    const newUser = await this.prisma.user.create({
      data: {
        phone,
        password: hashedPassword,
        roles: ['user'], // Default role
        isPhoneVerified: false,
        isEmailVerified: false,
        isVerified: false,
        // uuid will be auto-generated by Prisma
        // createdAt and updatedAt will be auto-generated by Prisma
      },
    });

    // Send OTP code for phone verification
    try {
      const otpCode = this.otpService.generateOtpCode();
      await this.otpService.storeOtpCode(phone, otpCode, 5);
      
      const smsResult = await this.smsService.sendOtpCode(phone, otpCode);
      
      if (!smsResult.success) {
        // If SMS sending failed, log but create user anyway
        console.error(`Failed to send OTP SMS to ${phone}: ${smsResult.error}`);
      }
    } catch (error) {
      // If OTP sending failed, log but create user anyway
      console.error(`Failed to send OTP to ${phone}:`, error.message);
    }

    return {
      message: 'User registered successfully. Please verify your phone number with the OTP code sent to your phone.',
      user: {
        id: newUser.id,
        uuid: newUser.uuid,
        phone: newUser.phone,
        roles: newUser.roles,
        isPhoneVerified: newUser.isPhoneVerified,
        isEmailVerified: newUser.isEmailVerified,
        isVerified: newUser.isVerified,
      },
    };
  }

  /**
   * Send OTP code for login
   * @param phone Phone number
   * @returns OTP sending result
   */
  async sendOtpForLogin(phone: string): Promise<{ message: string; expiresInMinutes: number }> {
    // Check if user exists in database
    const user = await this.prisma.user.findUnique({
      where: { phone },
      select: { id: true, phone: true },
    });

    if (!user) {
      throw new NotFoundException('User not found. Please register first.');
    }

    // Generate OTP code
    const otpCode = this.otpService.generateOtpCode();
    
    // Store OTP code
    await this.otpService.storeOtpCode(phone, otpCode, 5);

    // Send SMS
    const smsResult = await this.smsService.sendOtpCode(phone, otpCode);
    
    if (!smsResult.success) {
      throw new Error(`Failed to send SMS: ${smsResult.error}`);
    }

    return {
      message: 'OTP code sent successfully',
      expiresInMinutes: 5,
    };
  }

  /**
   * Verify OTP code and login user
   * @param phone Phone number
   * @param otpCode OTP code
   * @returns User information and token
   */
  async verifyOtpAndLogin(phone: string, otpCode: string): Promise<VerifyOtpResponseDto> {
    // Verify OTP code
    const isValidOtp = await this.otpService.verifyOtpCode(phone, otpCode);
    
    if (!isValidOtp) {
      throw new UnauthorizedException('Invalid or expired OTP code');
    }

    // Find user
    const user = await this.prisma.user.findUnique({
      where: { phone },
    });

    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    // Delete OTP code after successful use
    await this.otpService.deleteOtpCode(phone);

    // If phone number is not verified yet, verify it
    let updatedUser = user;
    if (!user.isPhoneVerified) {
      updatedUser = await this.prisma.user.update({
        where: { id: user.id },
        data: { isPhoneVerified: true },
      });
    }

    // Generate real JWT token
    const tokenResult = this.jwtService.generateToken(updatedUser.id, updatedUser.phone, updatedUser.roles);

    return {
      message: 'Phone number verified successfully. You are now logged in.',
      accessToken: tokenResult.accessToken,
      user: {
        id: updatedUser.id,
        uuid: updatedUser.uuid,
        phone: updatedUser.phone,
        roles: updatedUser.roles,
        isPhoneVerified: updatedUser.isPhoneVerified,
        isEmailVerified: updatedUser.isEmailVerified,
        isVerified: updatedUser.isVerified,
      },
    };
  }
}
